package com.wf.charpter03;

/**
 * @Author: wangfa
 * @Date: 2019/4/21 15:14
 * @Description: 模板方法模式(将具体处理交给子类)
 *
 * 父类中定义处理流程的框架，在子类中实现具体处理的模式
 */
public class DemoMain {

    /**
     *
     * template method 模式中角色
     *
     *
     * AbstractClass(抽象类)
     * abstractClass不仅负责实现模板方法，还负责声明在模板方法中用到的抽象方法，这些抽象方法有子类ConcreteClass角色负责实现
     *
     *
     * ConcreteClass(具体类)
     * ConcreteClass具体实现AbstractClass角色中定义的抽象方法，这里实现的方法将在AbstractClass角色中的模板方法中被调用
     *
     *
     *
     * 扩展
     * 可以使逻辑处理通用化，在父类中已经编写了算法，因此我们不需要在子类中再进行编写算法。
     *
     * 父类与子类之间的协作
     * 在template method模式中，父类和子类时紧密联系的，共同工作的。在子类中实现父类中声明的抽象方法时，必须要理解这些抽象方法调用的时机，
     * 即在父类的源代码的情况下，想要编写出子类时非常困难的。
     *
     *父类与子类的一致性，在示例程序中，不管是CharDisplay还是StringDisplay的实例，都是先保存在AbstractDisplay类型的变量中，然后再调用display方法。
     * 使用父类类型保存子类实例的优点是，即使没有instanceof等制定子类的种类，程序也能工作。
     *
     * 无论在父类类型的变量中保存那个子类的实例，程序都可以正常工作，这种原则称为里氏替换原则(LSP)。
     *
     * 延伸阅读 类的层次和抽象类
     *
     * 在理解类的层次时，通常是站在子类的角度进行思考的，很容易考虑:
     *  在子类中可以使用父类中定义的方法，
     *  在子类中可以通过添加方法来实现新的功能，
     *  在子类中重写父类的方法进行程序行为的改变，
     *
     * 站在父类的角度来进行考虑，我们声明了抽象方法，而将改方法的实现交给子类，我们希望:
     * 期待子类去实现抽象方法，和要求子类去实现抽象方法，
     * 也就是说，子类具有实现在父类中所声明的抽象方法的责任。因此，这种责任被称为子类责任。
     *
     * 抽象类的意义
     * 由于在抽象方法中没有编写具体的实现，所以我们无法知道在抽象方法中到底进行了什么样的操作，但是我们可以决定抽象方法的名称，
     * 然后通过调用抽象方法的模板方法区编写处理，虽然具体的处理内容是在子类中决定的，不过在抽象类阶段确定处理的流程非常重要。
     *
     *
     *
     *
     *
     *
     *
     */
}
